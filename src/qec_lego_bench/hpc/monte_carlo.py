from typing import Any, Protocol, Callable, TypeVar, Type
from dataclasses import dataclass
from dataclasses_json import dataclass_json
from distributed import Future, Client, wait
from concurrent.futures._base import DoneAndNotDoneFutures, FIRST_COMPLETED
import functools
import time

T = TypeVar("T")


class MonteCarloResult(Protocol):
    def __add__(self: T, other: T) -> T: ...

    # the following two methods are automatically generated by the dataclass_json decorator
    def to_dict(self) -> dict: ...
    @classmethod
    def from_dict(cls: Type[T], value: dict) -> T: ...


@dataclass_json
@dataclass
class LogicalErrorResult(MonteCarloResult):
    errors: int = 0

    def __add__(self, other: "LogicalErrorResult") -> "LogicalErrorResult":
        return LogicalErrorResult(self.errors + other.errors)  # type: ignore


MonteCarloFunc = Callable[..., MonteCarloResult]

Result = TypeVar("Result", bound=MonteCarloResult)


@dataclass(frozen=True)
class JobParameters:
    args: tuple
    kwargs: dict

    def __post_init__(self):
        assert hash(self) != 0, "test hash value to make sure it is hashable"

    @functools.cached_property
    def hash(self) -> int:
        _kwargs_ordered = tuple((k, self.kwargs[k]) for k in sorted(self.kwargs.keys()))
        for arg in self.args:
            try:
                hash(arg)
            except Exception as e:
                print(f"Error hashing positional argument {arg}: {e}")
                raise e
        for key, value in _kwargs_ordered:
            try:
                hash(key)
                hash(value)
            except Exception as e:
                print(f"Error hashing keyword argument {key}={value}: {e}")
                raise e
        return hash((self.args, _kwargs_ordered))

    def __hash__(self):
        return self.hash


class MonteCarloJob:

    def __init__(
        self, result_constructor: Callable[[], Result], *args, **kwargs
    ) -> None:
        self._params = JobParameters(args, kwargs)
        self.finished_shots: int = 0
        self.pending_shots: int = 0
        self.duration: float = 0  # overall time of the finished shots
        self.result = result_constructor()

    @property
    def args(self) -> tuple:
        return self._params.args

    @property
    def kwargs(self) -> dict:
        return self._params.kwargs

    def __getitem__(self, key: str) -> Any:
        return self.kwargs[key]

    @property
    def expecting_shots(self) -> int:
        return self.pending_shots + self.finished_shots

    @property
    def shots(self) -> int:
        return self.finished_shots

    def __hash__(self):
        return hash(self._params)


@dataclass
class MonteCarloExecutorConfig:
    # at least make the job run for 3 second before estimating how fast it runs
    estimation_min_time: float = 3
    # let each job run for about 3 minutes to reduce scheduling overhead
    target_job_time: float = 180


class MonteCarloJobExecutor:
    jobs: dict[int, MonteCarloJob]

    def __init__(
        self,
        client: Client,
        func: MonteCarloFunc,
        *jobs,
    ) -> None:
        self.func = func
        self.jobs = {hash(job): job for job in jobs}
        self.pending_futures: list[Future] = []
        self.future_info: dict[Future, MonteCarloJob] = {}

    def add_job(self, job: MonteCarloJob) -> None:
        self.jobs[hash(job)] = job

    def get(self, *args, **kwargs) -> MonteCarloJob:
        hash_value = hash(JobParameters(args, kwargs))
        if hash_value not in self.jobs:
            raise KeyError(f"Job parameters not found")
        return self.jobs[hash_value]

    def execute(self, timeout: float) -> None:
        start = time.time()
        while True:
            try:
                remaining_time = timeout - (time.time() - start)
                if remaining_time <= 0:
                    break
                futures: DoneAndNotDoneFutures = wait(
                    self.pending_futures,
                    return_when=FIRST_COMPLETED,
                    timeout=timeout - (time.time() - start),
                )
                for done in futures.done:
                    assert isinstance(done, Future)
                    job = self.future_info[done]
                    job.result()
                    del self.future_info[done]
                self.pending_futures = list(futures.not_done)  # type: ignore
            except Exception as e:
                print(f"Error in the loop: {e}")
                break
        # cancel all pending futures
        for future in self.pending_futures:
            future.cancel()
        self.pending_futures = []
