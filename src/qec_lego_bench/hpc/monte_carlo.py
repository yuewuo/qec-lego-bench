from typing import Any, Protocol, Callable, TypeVar
from dataclasses import dataclass
from distributed import Future, Client


class MonteCarloResult(Protocol):
    def add(self, other: "MonteCarloResult") -> "MonteCarloResult": ...

    # the following two methods are automatically generated by the dataclass_json decorator
    def to_dict(self) -> dict: ...
    @staticmethod
    def from_dict(value: dict) -> "MonteCarloResult": ...
    @staticmethod
    def empty() -> "MonteCarloResult": ...


MonteCarloFunc = Callable[..., MonteCarloResult]

Result = TypeVar("Result", bound=MonteCarloResult)


@dataclass(frozen=True)
class JobParameters:
    args: tuple
    kwargs: dict

    def __post_init__(self):
        self._kwargs_ordered = tuple(
            (k, self.kwargs[k]) for k in sorted(self.kwargs.keys())
        )
        self._hash = self.hash()

    def hash(self) -> int:
        for arg in self.args:
            try:
                hash(arg)
            except Exception as e:
                print(f"Error hashing positional argument {arg}: {e}")
                raise e
        for key, value in self._kwargs_ordered:
            try:
                hash(key)
                hash(value)
            except Exception as e:
                print(f"Error hashing keyword argument {key}={value}: {e}")
                raise e
        return hash((self.args, self._kwargs_ordered))

    def __hash__(self):
        return self._hash


class MonteCarloJob:

    def __init__(self, empty_result: Callable[[], Result], *args, **kwargs) -> None:
        self._params = JobParameters(args, kwargs)
        self.finished_shots: int = 0
        self.pending_shots: int = 0
        self.result = empty_result()

    @property
    def args(self) -> tuple:
        return self._params.args

    @property
    def kwargs(self) -> dict:
        return self._params.kwargs

    def __getitem__(self, key: str) -> Any:
        return self.kwargs[key]

    @property
    def expecting_shots(self) -> int:
        return self.pending_shots + self.finished_shots

    @property
    def shots(self) -> int:
        return self.finished_shots

    def __hash__(self):
        return hash(self._params)


@dataclass
class MonteCarloExecutorConfig:
    # at least make the job run for 3 second before estimating how fast it runs
    estimation_min_time: float = 3
    # let each job run for about 3 minutes to reduce scheduling overhead
    target_job_time: float = 180


class MonteCarloJobExecutor:
    jobs: dict[int, MonteCarloJob]

    def __init__(
        self,
        client: Client,
        func: MonteCarloFunc,
        *jobs,
    ) -> None:
        self.func = func
        self.jobs = {hash(job): job for job in jobs}
        self.pending_futures: list[Future] = []

    def add_job(self, job: MonteCarloJob) -> None:
        self.jobs[hash(job)] = job

    def get(self, *args, **kwargs) -> MonteCarloJob:
        hash_value = hash(JobParameters(args, kwargs))
        if hash_value not in self.jobs:
            raise KeyError(f"Job parameters not found")
        return self.jobs[hash_value]

    def warm_up(self) -> None:
        # run the jobs until all of them have reached `estimation_min_time` duration
        return

    def execute(self, timeout: float) -> None: ...
